# 메모리
개발자들은 항상 적은 Latency와 데이터에 빠르게 접근(Access)할 메모리로 구현하길 원한다. 하지만 이런 고성능의 메모리는 더 비싼 비용(cost)을 요구한다.

그렇기에 메모리의 성능과 용량에 따라 계층을 나눠 효율적으로 구성하게 되었다. 


# 메모리 계층 구조(Memory Hierachy)
 - 메모리의 성능, 용량, 비용에 따라 계층이 구성된다.

## 레지스터


## 캐시메모리
 - 주 용어
   - **hit** : 적중, CPU가 캐시메모리부터 접근하여 데이터를 찾은경우
     - **hit rate(ratio)**: 적중률, Cache Hit Count / 전체 메모리 참조 Count * 100 
   - **Miss** : 실패, CPU가 캐시메모리 없이 주기억장치에서 데이터를 찾을때.
     - **Miss rate:** 1 - hit rate
     - **Compulsory  Mise:** 최초에 메모리에 접근시 캐시메모리에 저장하기 위해 발생하는 캐시미스, 
     - **Capacity miss:** 캐시메모리의 용량이 부족하면 발생하는 미스
     - **Conflict miss:** 기존 Set에 다른 데이터가 참조할때 발생하는 미스
        + set: 데이터를 저장하는 공간의 단위
        + way: 세트에 저장할수 있는 데이터의 수
     - **Coherence miss:** 
        + write miss
        + write back miss
        + read miss
    - **Flush:** 캐시 메모리에 저장된 데이터를 제거하는 행위.
      -  **Write back flush**:
      -  **Write through flush:**
      -  **Eviction flush:**

### Locality
지역성은 CPU가 메모리에 저장된 데이터를 접근하는 방식에 대한 개념이다.

 #### 시간적 지역성 (temporal locality)
- CPU가 최근에 접근한 데이터를 다시 접근할 가능성이 높음.
- 분기, 루프, 지역 변수가 시간적 지역성에 속한다.

```cpp 
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> arr = {1,2,3,4,5};
    
    for(int i = 0; i < arr.size(); i++) {
        std::cout << arr[i] << std::endl;
    }

    return 0;
}
```
위의 코드에서 `arr`이라는 변수가 왜 시간적 지역성의 성격을 띄는지 저 반복문을 알아보자. 

```cpp
arr[0], arr[1] ... arr[5]
```
1. CPU는 최초로 `arr[0]`을 메모리에서 읽어온 뒤 캐쉬메모리에 저장한다.
2. 메모리에서 `arr[1]`을 읽어온다.
3. 캐시 메모리에 접근해서 arr[0]과 비교한다.
4. arr[1]

만약 CPU가 메모리에서 데이터를 읽어오는데 걸리는 시간이 `100ns`라고 가정하면

- arr[0]을 캐시메모리에 저장하지 않을 때
$ T = 5 * 100ns = 500ns $
- arr[0]을 캐시메모리에 저장할 때
$ T = 4 * 100ns = 400ns $

물론, 최초에는 캐시메모리에 저장하는 시간을 포함해 `500ns`가 걸림.

 #### 공간적 지역성 (spatial locality)

> ## bandwitdh와 through put의 차이
>
> `메모리 대역폭`: 
>   - 초(s)당 메모리에서 전송할 수 있는 데이터의 양
>   - 단위: MB/s, GB/s
>   - 대상: 메모리
> `ThroughPut`:
>   - 초(s)당 시스템을 통해 전송할 수 있는 데이터의 양
>   - 단위: MB/s, GB/s, TPS, PPS
>   - 시스템 전체  



## 3. 메모리(주 기억장치)

## 4. HDD or SSD(보조 기억장치)


# 메모리 종류
주기억장치

보조기억장치