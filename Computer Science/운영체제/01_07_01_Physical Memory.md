
- 프로세스는 실행중인 프로그램이라는 의미로 주 기억장치 위에서 수행함.
- 메모리는 각각 주소의 바이트 배열로 구성되어있다.
- CPU는 프로그램 카운터를 사용하여 메모리부터 명령어를 가져온다.


# 메모리 공간
- 프로세스는 각각의 독립된 메모리 주소를 보장해야함.
- 프로세스가 할당되기 위한 메모리 범위를 지정하기 위해 시작 주소(Base Register)와 종료 주소(Limit Register)를 제공.
	- `Base Register`: 프로세스가 메모리에 할당될 때 주소의 시작점.
	- `Limit Register`: 프로세스가 메모리에 할당될 때 주소의 마지막 지점
- 각 프로세스는 자신의 메모리 주소만 사용하여 작업을 수행, 액세스 시 충돌 방지.


### 메모리 공간 보호
![[Memory_trap.png]]
- CPU가 User Mode에서 특정 메모리 공간에 위치한 프로세스를 접근했을때, Base와 Limit register를 초과 할경우 Trap을 건다.
- 프로세스간 코드, 데이터 구조를 수정되는 것을 방지 할 수 있다. 

# 주소 할당
메모리 주소는 두가지 방식으로 나뉜다

- Vritual Address
	- 
- Physical Address



### Binding 시점

Binding을 하는 시점은 3가지로 나뉜다. 현대에서는 주로 **Execution TIme,** 가상화 메모리와 MMU를 활용한 **실행시간 주소 바인딩**을 활용한다

- **Compile Time**
	- 컴파일 시, 메모리 주소가 결정되며, 메모리주소가 고정된 Absolute Code를 생성한다.
	- 만약 메모리 시작 위치가 바뀐다면, 컴파일을 다시 수행해야한다.
	- 프로그램이 항상 동일한 위치에서 실행되나, 메모리 위치가 변경되면 다시 컴파일을 수행해야하므로 잘 쓰이지 않음
- **Load Time**
	- 주소가 고정되지 않고 프로그램을 실행 시(메모리에 로드 시) 결정되는 방식.
	- 메모리의 어느 위치에서든 실행 가능하나 다른 위치로 이동하면 주소를 다시 계산해야함.
	- 프로그램이 메모리의 다른 위치로 이동하면, 모든 주소를 다시 바인딩 해야하므로 쓰이지 않음.
- **Execution Time**
	- 프로세스가 실행되는 동안 새로운 주소로 바인딩 될 수 있다.
	- 주로 가상메모리 환경에서 발생하며, 실제로 메모리에 액세스 하려는 시점에 바인딩.
	- **메모리 관리 유닛(Memory Management Unit, MMU)**에 의해 처리
	- 가상주소를 물리 주소로 변경하는 과정에서 오버헤드가 발생할 수 있어, 복잡한 메모리 관리 알고리즘이 필요할 수 있음.



### 메모리 관리 유닛, MMU


# 페이징 




