
- 프로세스는 실행중인 프로그램이라는 의미로 주 기억장치 위에서 수행함.
- 메모리는 각각 주소의 바이트 배열로 구성되어있다.
- CPU는 프로그램 카운터를 사용하여 메모리부터 명령어를 가져온다.


# 메모리 공간
- 프로세스는 각각의 독립된 메모리 주소를 보장해야함.
- 프로세스가 할당되기 위한 메모리 범위를 지정하기 위해 시작 주소(Base Register)와 종료 주소(Limit Register)를 제공.
	- `Base Register`: 프로세스가 메모리에 할당될 때 주소의 시작점.
	- `Limit Register`: 프로세스가 메모리에 할당될 때 주소의 마지막 지점
- 각 프로세스는 자신의 메모리 주소만 사용하여 작업을 수행, 액세스 시 충돌 방지.


### 메모리 공간 보호
![[Memory_trap.png]]
- CPU가 User Mode에서 특정 메모리 공간에 위치한 프로세스를 접근했을때, Base와 Limit register를 초과 할경우 Trap을 건다.
- 프로세스간 코드, 데이터 구조를 수정되는 것을 방지 할 수 있다. 

# 주소 할당
메모리 주소는 두가지 방식으로 나뉜다

- Vritual Address
	- 
- Physical Address



### Binding 시점

Binding을 하는 시점은 3가지로 나뉜다. 현대에서는 주로 **Execution TIme,** 가상화 메모리와 MMU를 활용한 **실행시간 주소 바인딩**을 활용한다

- **Compile Time**
	- 컴파일 시, 주소 위치 결정.
	- 시작 위치가 바뀔 시, 컴파일을 다시 수행.
	- 즉, 추가적인 주소나, 프로그램이 실행되는 동안 주소 변경이 불가능
	- 프로그램이 항상 동일한 위치에서 실행되나, 메모리 위치가 변경되면 다시 컴파일을 수행해야하므로 잘 쓰이지 않음
- **Load Time**
	- 메모리에 로드 시, 주소 위치 결정
	- 어느 위치에서든 실행이 가능하나, 각 실행마다 위치 주소를 계산.
	- 즉, 프로그램을 추가로 실행할 경우, 다른 위치로 이동할경우 바인딩해야할 주소를 계산.
	- 결국 로드시 주소를 매번 바인딩 해야하므로 쓰이지 않음.
- **Execution Time**
	- 프로세스가 실행되는 동안 새로운 주소로 바인딩 될 수 있다.
	- 주로 가상메모리 환경에서 발생하며, 실제로 메모리에 액세스 하려는 시점에 바인딩.
	- **메모리 관리 유닛(Memory Management Unit, MMU)**에 의해 처리
	- 가상주소를 물리 주소로 변경하는 과정에서 오버헤드가 발생할 수 있어, 복잡한 메모리 관리 알고리즘이 필요할 수 있음.



### 메모리 관리 유닛, MMU
- Execution TIme에 가상 주소를 물리 주소로 변환하는 하드웨어 장치
- CPU와 메인메모리 사이에 위치
- 


### 왜 MMU에서는 Execution Time 주소 바인딩을 사용할까?
- 컴파일, 로드 주소 바인딩에서는 컴파일시 혹은 메모리 로드되는 시점에서 위치가 결정되기 때문에 정적으로 할당된다.
- 반면 Execution Time은 프로세스가 메모리로 로드되고 실행되는 동안 **가상메모리**를 활용해 주소가 동적으로 변환이 이루어지기 때문이다.
- relocation register
# 페이징 




